<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title> MinIniP: a Minimalist INI Parser </title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>

    <body>
        <header>
            <ul class="related-links">
                <li> <a href="https://github.com/BorisDRYKONINGEN/mininip"> Repository </a> </li>
                <li> <a href="target/doc/mininip/index.html"> API reference </a> </li>
                <li> <a href="mailto:boris.d@orange.fr"> Contact me </a> </li>
            </ul>
        </header>


        <h1> MinIniP </h1>
        <main>
            <h2 id="what-is-mininip"> <a href="#what-is-mininip">What is MinIniP ?</a> </h2>

            <article>
                <h3 id="presentation"> <a href="#presentation">Presentation</a> </h3>
                <p>
                    <strong>MinIniP</strong> stands for <q>Minimalist <abbr title="Initialization files">INI</abbr> Parser</q>.
                    It is a parser written in Rust to store datas in an easy and safe way. Currently, it is not intended to be extremly
                    fast and there is not any benchmark of it. You can use it like you want in any project. Every change to one of the
                    provided files must be published under the <abbr title="Mozilla Public License 2.0">MPL-2.0</abbr>.
                </p>
            </article>

            <article>
                <h3 id="why-mininip"> <a href="#why-mininip">Why MinIniP ?</a> </h3>
                <p>
                    Honnestly, there is not any particular reason to chose MinIniP. I just wrote it to play with Rust which I learn a few
                    months ago. I will use it in my personnal projects so it will be actively maintained for a long time.
                </p>
            </article>

            <article>
                <h3 id="how-to-use"> <a href="#how-to-use">You convinced me ! How to use it ?</a> </h3>
                <p>
                    Just add
                </p>
                <pre><code>mininip="1.2"</code></pre>
                <p>
                    to your <code>Cargo.toml</code> in the <code>dependencies</code> section and you are right ! You can also download
                    it at <a href="https://github.com/BorisDRYKONINGEN/mininip">the official repository</a>.
                </p>
            </article>
        </main>

        <section>
            <h2 id="valid-ini"> <a href="#valid-ini">What is a valid INI file ?</a> </h2>

            <article>
                <h3 id="no-std"> <a href="#no-std">A lack of standardisation</a> </h3>

                <p>
                    Since there is not any standard INI specification, each implementor writes its own. Here is mine. You can contribute to
                    the project by extending this specification if you think something is missing. The only rule to follow is to not break
                    backward compatibility, except in one case : adding a new INI types may break some use cases of the <code>Raw</code>
                    type by moving a declaration of variable to the new type.
                </p>
                <p>
                    For instance, you may create a <code>Set</code> INI type which is like the sets in maths, and is enclosed by curly
                    braces <code>{}</code>. In this way, parsing this line
                </p>
                <pre><code><span class="ini_key">an INI key</span> = <span class="literal">{ Hello, world, ! }</span></code></pre>
                <p>
                    Will no longer produce a <code>Value::Raw</code> value when parsing it but a <code>Value::Set</code> instead.
                </p>
            </article>

            <article>
                <h3 id="ini-specification"> <a href="#ini-specification">The specification followed by MinIniP</a> </h3>

                <h4 id="identifiers"> <a href="#identifiers">Identifiers</a> </h4>
                <p>
                    An identifier refers to either
                </p>
                <ul>
                    <li> A section name </li>
                    <li> A key name </li>
                </ul>

                <p>
                    An identifier must start with one of <code>.</code>, <code>$</code>, <code>:</code> or <code>a-zA-Z</code>. Since
                    the second character, all of <code>_</code>, <code>~</code>, <code>-</code>, <code>.</code>, <code>:</code>,
                    <code>$</code>, <code>a-zA-Z</code> and <code>0-9</code> are allowed. In the API, an
                    <a href="target/doc/mininip/datas/struct.Identifier.html"><code>Identifier</code></a> refers to a combination of a section
                    name and a key name, so be careful when using it !
                </p>
                <p>
                    The specification above might be outdated, so refer to <a href="target/doc/mininip/datas/struct.Identifier.html#is_valid">
                    Identifier::is_valid</a> to be aware of what is a valid INI identifier.
                </p>

                <h4 id="values"> <a href="#values">Values</a> </h4>

                <h5 id="declaring-a-value"> <a href="#declaring-a-value">Declaring a value</a> </h5>
                <p>
                    A value can be anything following the first <code>=</code> sign in an expression. It must be assigned to a key and not
                    a section. In this code
                </p>
                <pre><code><span class="ini_key">key</span>=<span class="literal">value</span></code></pre>
                <p>
                    <code><span class="ini_key">key</span></code> must be a valid identifier and <code><span class="literal">value</span></code> is defined as the value.
                </p>

                <h5 id="types"> <a href="#types">Types</a> </h5>
                <p>
                    A value can be either
                </p>
                <ul>
                    <li> <code>Raw</code> a valid value which does not match with any of the types above </li>
                    <li> <code>Str</code> a valid value inside two quotes <code>'</code> or <code>"</code> </li>
                    <li> <code>Int</code> a 64-bits-sized integer </li>
                    <li> <code>Float</code> a 64-bits-sized floating-point number </li>
                    <li> <code>Bool</code> a boolean (either <code>true</code> (<code>on</code>, <code>enabled</code>,
                    <code>y</code> or <code>yes</code>) or <code>false</code> (<code>off</code>, <code>disabled</code>,
                    <code>n</code> or <code>no</code>)
                </ul>
                <p>
                    The highest priority is for the type <code>Str</code>. Since quotes are forbidden in all the other use cases,
                    a quoted value can be only a <code>Str</code>. Then, comes the <code>Bool</code> type which only allows a few
                    values (see above). Then, comes <code>Int</code> and in case of failure while interpetting it as an integer,
                    <code>Float</code>. If none of these types match with the given value, the value is <code>Raw</code> which is
                    the value as written in the file (after unescaping, defined below).
                </p>

                <h5 id="escape-sequences"> <a href="#escape-sequences">Escape sequences</a> </h5>
                <p>
                    In an INI file, all the possible values are <strong>not accepted</strong>. For instance, you can not store an emoji
                    (like ☺ or ♥) <em>as is</em> in a file. It is even true for characters which may be part of the INI syntax like the
                    semicolon <code>;</code>, the colon <code>:</code>, the equal sign <code>=</code>... However, you have not to deal
                    with these characters since MinIniP does it for you. The characters are <em>escaped</em>. Here is an exhaustive list
                    of the recognized escapes sequences.
                </p>
                <table>
                    <thead>
                        <tr>
                                 <th> Non-escaped </th>                 <th> Escaped </th>
                        </tr>
                    </thead>
                    <tbody>
                            <tr> <td> <code>\</code>    </td>         <td> <code>\\</code> </td> </tr>
                            <tr> <td> <code>'</code>    </td>         <td> <code>\'</code> </td> </tr>
                            <tr> <td> <code>"</code>    </td>         <td> <code>\"</code> </td> </tr>
                            <tr> <td> null character    </td>         <td> <code>\0</code> </td> </tr>
                            <tr> <td> bell / alert      </td>         <td> <code>\a</code> </td> </tr>
                            <tr> <td> backspace         </td>         <td> <code>\b</code> </td> </tr>
                            <tr> <td> tab character     </td>         <td> <code>\t</code> </td> </tr>
                            <tr> <td> carriage return   </td>         <td> <code>\r</code> </td> </tr>
                            <tr> <td> line feed         </td>         <td> <code>\n</code> </td> </tr>
                            <tr> <td> <code>;</code>    </td>         <td> <code>\;</code> </td> </tr>
                            <tr> <td> <code>#</code>    </td>         <td> <code>\#</code> </td> </tr>
                            <tr> <td> <code>=</code>    </td>         <td> <code>\=</code> </td> </tr>
                            <tr> <td> <code>:</code>    </td>         <td> <code>\:</code> </td> </tr>
                            <tr> <td> unicode character </td>         <td> <code>\x??????</code> with <code>??????</code>
                                                                      corresponding to its hexadecimal code (six digits) </td> </tr>
                    </tbody>
                </table>
                <p>
                    Please, note that escapes are <strong>not available</strong> for identifiers.
                </p>

                <h4 id="sections"> <a href="#sections">Sections</a> </h4>
                <p>
                    A section refers to what can be called in C++ a namespace, or a module in Rust. In a few words, it is a named or anonymous
                    set of keys. A section identifier must be a valid identifier or nothing at all. A section is declared by putting square
                    braces around its identifier on a line.
                </p>
<pre><code><span class="ini_key">ident_1</span> = <span class="literal">value_1</span>
<span class="ini_key">ident_2</span> = <span class="literal">value_2</span>

[<span class="section">section 1</span>]
<span class="ini_key">ident_1</span> = <span class="literal">value_3</span>
<span class="ini_key">ident_2</span> = <span class="literal">value_4</span>

[<span class="section">section 2</span>]
<span class="ini_key">ident_1</span> = <span class="literal">value_5</span>
<span class="ini_key">ident_2</span> = <span class="literal">value_6</span>
</code></pre>
                <p>
                    In this code, every occurences of <code>ident_1</code> and <code>ident_2</code> are different keys because they are
                    not in the same section. The first ones are in the global / anonymous section, the two followings one in a
                    <code>section 1</code>-named section, and the two last ones in a <code>section 2</code>-named section.
                </p>
                <p>
                    In this API, sections name are the first value stored in an <a href="target/doc/mininip/datas/struct.Identifier.html">
                    <code>Identifier</code></a>. It is a <code>Option&lt;String&gt;</code> since a section may be anonymous (the keys
                    declared before the first section are in the anonymous section corresponding to <code>None</code>). All the named
                    sections are represented as <code>Some(name)</code>. The second value is the key name, which is a <code>String</code>
                    that must be a valid identifier.
                </p>
            </article>
        </section>
    </body>
</html>
